---
title: "Practice of PCA"
author: "Marc Méndez Roca & Joel Cantero Priego"
date: "18/3/2019"
output:
  html_document: default
  pdf_document: default
---
```{r message=FALSE}
library(mice)
source("PCA.R")
```

## 1. Read again the Russet completed data set. Define as X matrix the one defined by the continuous variables. (Now, just using matrix operation)

In this exercise we will use the Russet data set. In 1964 Russet tried to find the relation between political instability of countries and the economical and agricultural inequality. Russett collected this data to study relationships between Agricultural Inequality, Industrial Development and Political Instability. Russett's hypotheses can be formulated as follows: It is difficult for a country to escape dictatorship when its agricultural inequality is above-average and its industrial
development below-average.

The collected data refer to 47 countries and 9 variables on the period after the Second World War (1945-1962). The Russett data set (Russett, 1964) are studied in Gifi (1990).
 
First of all, we are going to read 'Russet_ineqdata.txt' and put it to X variable. We have to set some parameters to read.table to function to indicate that:
1. This file has a header (header=T).
2. The rows file are separated by tabulation (sep='\t').
3. The first column contains the row names, they are not an attribute (row.names=1).

First of all, we are going to read again the Russet completed data set. So we have to read the original table and then we are going to impute the NA values. For this reason, before using MICE, we are going to convert demo attribute as a level (0: Stable, 1: Instable, 3: Dictatorship), MICE will impute better if we use demo as a level factor before we impute it. We will use md.pattern function that is useful for investigating any structure of missing observations in the data (there are two NA values). This mentioned function pertains to mice package. 

```{r upload}
X <- read.table('Russet_ineqdata.txt', header=T, sep='\t', row.names=1)
X$demo <- as.factor(X$demo)
levels(X$demo) = c("Stable", "Instable", "Dictatorship")
```

```{r using-mdpattern-plot}
md.pattern(X)
```
Thanks to md.pattern function, we can see there is some NA values that we have to deal with them. Once we have demo variable as a level, we can impute NA values using MICE function. We are going to use MICE function because it imputes the missing values of the variable from the predicted values of the regression of the current variable with the remaining ones (similar to lineal regression imputation).

```{r using-mdpattern}
imputedX <- complete(mice(X))
row.names(imputedX) <- row.names(X)

```
Once we have our imputed data, we are going to remove demo attribute level factor. Because we are going to use PCA, we are just interested in continuous variables. We are going to define our X.matrix defined by the continuous variables just using matrix operation.

```{r xmatrix}
X.matrix <- as.matrix(imputedX[,0:8])
```
## 1. PCA function
### a. Define the matrix N of weights of individuals (with uniform weights).

Once we have our complete dataset, we are going to define our weights vector with uniform weights (1) thanks to rep function. Rep functions will replicate a value as many times we set (number of rows of X.matrix). Then, we are going to define our N of weights of individuals thanks to diag function, that it will put our values (weights/sum(weights)) to matrix diagonal.


```{r weights}
weights <- rep(1,nrow(X.matrix))
weights <- weights/sum(weights) #Normalized 
N <- diag(weights) 
```

### b. Compute the centroid G of individuals.

Once we have calculated the matrix N of weights, we are going to calculate our centroid G, using colMeans function. This function calculates the mean of all column values.

```{r centroid-g}
G = vector()
for (i in 1:ncol(X.matrix)){
      G = c(G,weighted.mean(X.matrix[,i],weights))
  }
G
```

### c. Compute the covariance or correlation matrix of X (be aware of dividing by sum(weights_i)).

Using cov function we are going to calculate the covariance matrix of X, always dividing our X values to sum(weights). On the other hand, we are going to use cor function to calculate the correlation matrix of X. 

We can do it in two ways: using R functions or doing by ourselves manually. As we can see, both ways give us the same result.

```{r covariance-correlation}
X.centered <- X.matrix - rep(G, rep.int(nrow(X.matrix), ncol(X.matrix)))
X.covariance = (t(X.centered)%*%N%*%X.centered)/sum(weights)
X.standarized <- scale(X.matrix)
X.correlation <- (t(X.standarized)%*%N%*%X.standarized)/sum(weights)

euclidean <- TRUE

if (euclidean) {
  X <- X.standarized
  S <- X.correlation
} else {
  X <- X.centered
  S <- X.covariance
}
```

### d. Compute the centered X matrix and standardized X matrix.

```{r centered-matrix}
X.centered <- X - rep(G, rep.int(nrow(X), ncol(X)))
X.standarized <- scale(X, center = FALSE, scale=TRUE)
```

### e. Diagonalize XtNX, with X centered and X standardized.

```{r diagonalize-matrix}
X.svd <- svd(S)
X.values = X.svd$d
X.vector <- X.svd$u
```

###f. Do the screeplot of the eigenvalues and define the number of significant dimensions. How much is the retained information?
```{r eigenvalues-screeplot}
plot(X.values, type = "l", main="Screeplot of Russet")
```

###g. Compute the projections of individuals in the significant dimensions.
```{r projections-individuals}
PSI <- X %*% X.vector
```
###h. Compute the projection of variables in the significant dimensions.
```{r projections-variables}


PHI <- sqrt(X.values)*X.vector
PHI
```
###i. Plot the individuals in the first factorial plane of Rp. Color the individuals according the “demo” variable.
```{r plot-individuals}
plot(PSI, col=c('green', 'orange', 'red')[imputedX$demo])
legend(x="topright", legend=c('Stable', 'Instable', 'Dictatorship'), fill=c('green', 'orange', 'red'))
```
###j. Plot the variables (as arrows) in the first factorial plane of Rn
```{r plot-variables-as-arrows}
originx <- rep(0, ncol(PHI))
originy <- rep(0, ncol(PHI))
plot(PHI, xlim=c(min(PHI), max(PHI)), ylim=c(min(PHI), max(PHI)))
arrows(originx, originy, PHI[,1], PHI[,2])
```
###k. According to the Russet complete data, justify which metric M is appropriate for this problem.

Standarized is the special one because it is more dispars

###l. Compute the correlation of the variables with the significant principal components and interpret them.



```{r compute-correlation-variables}
COR <-cor(X, PSI)
plot(COR)
arrows(originx, originy, COR[,1], COR[,2])
```

## 3. Redo 2, but taking the weight of Cuba equal to 0.

Now, we are going to use our PCA function (that it is on PCA.R) but taking the weight of Cuba equal to 0. 
```{r using-Cuba}
weights <- rep(1,nrow(X.matrix))
weights[11] <-0
weights <- weights/sum(weights) #Normalized
PCA(X.matrix, weights, eucledian=TRUE)
```

## 4. Now, study the sensibility of the performed PCA respect to considering Cuba as an outlier. Compute the correlations of the obtained significant principal components (Cuba 0 weight) with the previous obtained ones (all cases equal weights).

```{r cuba-outlier}
weights <- rep(1,nrow(X.matrix))
weights[11] <-0
PCA(X.matrix, weights, eucledian=TRUE)
```

## 5. Do again the PCA, but now using the library “FactoMineR” (be aware of using the completed data file with the “demo” factor as illustrative and the selected Metric).

```{r factor-miner}
X.FactoMineR <- imputedX
pca <- FactoMineR::PCA(graph=T, X.FactoMineR, ncp=8, quali.sup=9)
plot(pca, cex=0.8, habillage='demo')
```


## 6. What is the country best represented in the first factorial plane?. And what is the worse?.

The best country represented in the first factorial plane is Yougoslavie and the worst one is Autriche.

```{r factorial-plane}
firstFactorialPlane <- sort(abs(pca$ind$cos2[,1])+abs(pca$ind$cos2[,2]), decreasing=TRUE)
bestCountry <- firstFactorialPlane[1]
worseCountry <- firstFactorialPlane[length(firstFactorialPlane)]
```

## 7. What are the three countries most influencing the formation of the first principal component?, and what are the three countries most influencing the formation of the second principal component?

```{r most-influencing}
contribPCA <- pca$ind$contrib
contribPCA.1 <- sort(abs(contribPCA[,1]), decreasing=TRUE)
contribPCA.2 <- sort(abs(contribPCA[,2]), decreasing=TRUE)
bestCountries.1 <- contribPCA.1[1:3]
bestCountries.2 <- contribPCA.2[1:3]
```
## 8. What is the variable best represented in the first factorial plane?. And what is the worse?.

```{r variable-represented}
variableRepresented <- sort(abs(pca$var$cos2[,1])+abs(pca$var$cos2[,2]), decreasing=TRUE)
best <- variableRepresented[1]
worse <- tail(variableRepresented, n=1)
```

## 9. What are the three variables most influencing the formation of the first principal component?, and what are the three variables most influencing the formation of the second principal component?
```{r three-variables-most-influencing}
firstPrincipalComponent <- sort(abs(pca$var$contrib[,1]), decreasing=TRUE)
secondPrincipalComponent <- sort(abs(pca$var$contrib[,2]), decreasing=TRUE)
mostInfluencingVariablesFirst <- firstPrincipalComponent[1:3]
mostInfluencingVariablesSecond <- secondPrincipalComponent[1:3]
```

## 10. Which modalities of the variable “demo” are significant in the first two principal components

```{r modalitites-variable-demo}
significantModalitiesDemo <- sort(abs(pca$quali.sup$cos2[,1]) + abs(pca$quali.sup$cos2[,2]), decreasing=TRUE)
```

## 11. Use the NIPALS algorithm to obtain Principal Components in standardized PCA (as determined in previous questions) and with the results of the NIPALS, obtain the biplot of Rp. Interpret the results. Use unweighted data only.
```{r nipals}
library(nipals)

```

## 12. Perform the Varimax rotation and plot the rotated variables. Interpret the new rotated components. Use unweighted data only.

```{r varimax-rotation}
PSI = pca$ind$coord[,1:2]
PHI = pca$var$coord[,1:2]
PC.ROT <- varimax(PHI)
PHI.ROT = PC.ROT$loadings[1:ncol(X),]
X = imputedX[,1:8]
Xs = scale(X)
iden = row.names(X)
etiq = names(X)
lmb.rot = diag(t(PC.ROT$loadings) %*% PC.ROT$loadings)
sum(lmb.rot)
sum(pca$eig[1:2,])
Psi_stan.rot = Xs %*% solve(cor(X)) %*% PHI.ROT
PSI.ROT = Psi_stan.rot %*% diag(sqrt(lmb.rot))
library(calibrate)
ze = rep(0,ncol(X))
plot(PHI.ROT,type="n",xlim=c(-1,1),ylim=c(-1,1))
text(PHI.ROT,labels=etiq, col="blue")
arrows(ze, ze, PHI.ROT[,1], PHI.ROT[,2], length = 0.07,col="blue")
abline(h=0,v=0,col="gray")
circle(1)
```
```{r second-plot}
plot(PSI.ROT,type="n")
text(PSI.ROT,labels=iden,col=as.numeric(imputedX$demo))
abline(h=0,v=0,col="gray")
```

## 13. Compute the scores of individuals in the rotated components Psi.rot. Interpret them (xxxx$ind$coord[,1:nd] = Psi.rot; dimdesc(xxxx,axes=1:nd). Use unweighted data only
```{r scores-individuals}
pca$ind$coord <- pca$ind$coord[,1:2] %*% PC.ROT$rotmat
FactoMineR::dimdesc(pca, axes=1:2)
```
